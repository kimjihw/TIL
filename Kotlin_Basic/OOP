2023-05-30

1. 클래스와 객체

클래스 -> 정의나 설계도
객체 -> 클래스의 인스턴스, 클래스가 설명하는 속성과 행위를 포함하는 엔티티

2. 속성과 행위

모든 클래스는 속성과 행위를 가짐

속성 -> 다른 클래스와 구별하는 데 도움이 되는 클래스의 특징
ex) 사람이라면 나이, 이름, 키

행위 -> 객체가 수행하는 동작
ex) 걷기, 먹기, 달리기

코틀린에서는 속성을 프로퍼티 행위를 함수라고 함

3. 객체지향 프로그래밍의 이점

절차적 프로그래밍 -> 어셈블리나 포트란 같은 언어로써 명령이 차례로 실행되기 때문에 하향식 접근방식이라고 함

단점

- 정보 은닉 메커니즘이 없어 데이터는 전체 시스템에 노출
- 데이터와 함수는 별도의 메모리 위치에 저장
- 코드를 재사용할 수 없음
- 코드를 확장 할 수 없음
- 함수 하나만 변경해도 나머지 애플리케이션에 영향을 미칠 수 있음

장점

- 함수와 절차를 구현하는 것이 쉬움
- 프로그램 흐름을 쉽게 추적 가능
- 논리가 복잡하지 않음

OOP 이점

- 캡슐화 -> 데이터가 완전히 은닉되어있으며 애플리케이션의 다른 부분으로부터 보호
- 요청에 따라 데이터 공개
- 상속 -> 코드의 재사용성
- 다형성 -> 객체는 상황에 따라 다르게 동작 가능
- 데이터와 함수는 하나의 메모리 위치에 저장
- 디자인 패턴은 객체지향 프로그래밍 기술을 기반으로 함

단점

- 복잡한 로직을 갖고 있기 때문에 잘 구조화된 아키텍처로 설계하려면 더 많은 작업이 필요
- 프로그래밍의 복잡성으로 인해 버그를 찾기 어려움
- 많은 메모리 공간 필요
- 절차적 프로그래밍보다 느림

4. 코틀린

코틀린에서 데이터클래스를 생성할 때 val로 생성하면 getter만 제공됨 -> val은 불변적이기 때문

생성자는 객체가 만들어질 때나 구체적으로 공간이 메모리에 할당될 때 호출
생성자는 constructor 키워드를 사용하여 선언할 수 있다.
생성자는 Units을 포함해 어떤 반환 유형도 없다.

기본 생성자

class Person(var name : String = "Abid", var age : Int = 40, var height : Double = 0.0)

val person = Person() 

이런 식으로 기본 생성자는 인수가 없는 생성자이며 클래스의 모든 프로퍼티는 고정된 초깃값만 가짐

객체를 생성할 때 가장 좋은 방법은 주생성자를 사용

주생성자 -> 초깃값을 갖는 생성자

class Person(val name : String, var age: Int, var height : Double) -> class Person constructor(val name : String, var age: Int, var height : Double)

5. init

클래스 안에 직접 코드를 작성하는 것은 깔끔한 방법이 아님.

class Person(pName : String, pAge : Int, pHeight : Double){
    val name : String,
    var age: Int, 
    var height : Double

    init{
        name = pName
        age = pAge
        height = pHeight
    }
}

init 키워드를 사용하여 블록을 만들고 클래스 매개변수를 사용해 블록 내의 모든 프로퍼티를 초기화
init 함수는 주 생성자를 사용해 클래스를 만들 때만 실행

코틀린의 require함수는 유효성 확인하는데 도움이 될 수 있음

ex) require(age > 0) {"Age is not correct"}

이걸 init 함수와 같이 사용 가능

class Person(pName : String, pAge : Int, pHeight : Double){
    val name : String,
    var age: Int, 
    var height : Double

    init{
        name = pName
        age = pAge
        height = pHeight

        require(name.trim().isNotEmpty()){"Name should not empty"}
        require(age > 0) {"Age is not correct"}
        require(height > 0) {"Height is not correct"}
    }
}

또한 require은 메시지와 함께 IllegalArgumentException을 발생시킴

require뿐만 아니라 requireNotNull, check, checkNotNull도 있음

6. this

현재 객체를 참조하고자 사용

class Person(pName : String, pAge : Int, pHeight : Double){
    val name : String,
    var age: Int, 
    var height : Double

    init{
        this.name = pName
        this.age = pAge
        this.height = pHeight
    }
}

사용하는 주요 이유는 클래스 프로퍼티와 지역변수 사이의 모호성을 없애기 위함

부 생성자는 constructor 키워드가 접두어로 사용된다.

class Person(pName : String, pAge : Int, pHeight : Double){
    val name : String,
    var age: Int, 
    var height : Double

    init{
        name = pName
        age = pAge
        height = pHeight

        init{
            this.name = pName
            this.age = pAge
            this.height = pHeight
        }
    }

    constructor(name : String, age : Int, height : Double) : this(name,age){
        this.height = height
    }
}

클래스를 초기화해야 할 때 필요

부 생성자를 사용하여 객체를 만들면 this 키워드로 주 생성자를 호출하여 클래스 프로퍼티를 초기화₩

클래스에 두 개 이상의 생성자가 있으면 각 생성자마다 다른 매개변수가 있어야 함