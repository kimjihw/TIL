[2023-06-27]

1. Sealed Class, Enum Class

- 클래스의 주목적은 다른 클래스가 서로를 확장하고 코드 재사용성과 유지 보수성을 최대한 활용하는 것

1.1 Sealed Class 
- 상속의 제한을 둠 
- 예전에는 클래스 내부에서 자식 클래스를 선언해야 하였는데 지금은 같은 파일 안에서만 선언되면 된다.

ex) 같은 클래스 안에 있을 경우 불러올 때 A.B() 이렇게 불러오는데 외부에 있을 경우 var d = D() 이런 식으로 불러오면 된다.

when 절을 할 경우 일반적으로 else 블록을 붙여야 하지만 Sealed Class 는 사용하지 않는다.

1.2 Enum Class

- 위의 클래스와 비슷하지만 모든 값이 같은 유형이라는 점만 다름
- 몇 개의 색상이나 요일과 같은 결과가 작은 집합을 나타낼 때 유용

ex) enum class Color {
    RED,
    GREEN,
    BROWN,
    YELLOW
}

이런식으로 되어 있다면 Color.RED, Color.RED.name 으로 불러오면 값을 가져오고 Color.RED.ordinal 으로 불러오면 인덱스 값을 가져온다

- 각 멤버는 0부터 시작하는 정수 값을 포함하지만 생성자를 사용하여 선택한 값을 할당할 수 있다.

ex) enum class Week(val value : Int){
    MONDAY(2), TUESDAY(5)
}

- 코틀린에서는 세미콜론을 사용하지 않지만 열거형 클래스에 하나 이상의 프로퍼티와 생성자가 포함되어 있으면 세미콜론을 사용해야 함

- 열거형 클래스는 인터페이스도 구현 가능 -> 열거형 클래스의 각 멤버는 인터페이스에 언급된 각 함수 서명의 함수 본문을 제공해야 함

- 값을 알고 싶으면 Week.valueOf(변수)를 하면 됨

[2023-07-10]

1. 객체와 컴패니언 객체

- 싱글톤 : 애플리케이션 수명 주기 동안 클래스가 하나의 인스턴스만 갖는 것을 말함, 모든 함수와 클래스에서 전역적으로 사용 가능 -> 코틀린은 object 키워드를 사용하여 가능
즉, 최초 한번만 메모리를 new 로 할당하고 이 메모리에 인스턴스를 만들어 사용

장점
- 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지
- 싱글톤으로 만들어진 클래스의 인스턴스는 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움
- 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 경우 사용

-> DBCP(DataBaseCommection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야 하는 상황에서 많이 사용

단점
- 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우에 다른 클래스의 인스턴스들 간에 결합도가 높아져 OCP를 위배
- 멀티쓰레드 환경에서 동기화 처리를 안하면 인스턴스 2개가 생성 될 수 있는 가능성이 생김

ex) object singletonClassName{
        properties
        fun function(){
            function body
        }
}

- object 키워드는 클래스 선언에 사용됨
- 이 클래스의 인스턴스를 만들 수 없음
- 이 클래스로 생성자를 선언할 수 없음

[2023-07-12]

1. 컴패니언 객체

코틀린은 static 키워드를 제공하지 않아 컴패니언 객체를 추가

클래스 하나당 컴패니언 하나만 가능


[2023--7-18]

1. 집합, 구성, 중첩 클래스

상속에서 클래스는 항상 is-a 관계를 가짐

1.1 집합

객체가 본문에 다른 객체를 포함할 때 객체 간의 관계를 집합이라고 함

ex) 방에 의자가 있다. 정원에 식물이 있다. 개에게 주인이 있다.

이 관계는 한 객체가 다른 객체를 갖고 있기에 has-a 관계라고 함

객체는 둘 이상의 객체와 관계를 가질 수 있음

ex) 정원에는 많은 식물이 있다. 회사에는 많은 직원이 있다.

1.2 구성

구성은 두 객체가 서로에 크게 의존하는 고급 집합 형태

집합에서는 하나의 객체가 다른 객체를 포함하는 반면 구성에서 하나의 객체는 다른 객체를 소유 -> 소유한 객체가 없어지면 소유된 객체도 없어짐

1.3 중첩 클래스

한 클래스의 기능을 캡슐화 할 때 유용

Nested Class 와 Inner Class 차이

중첩 클래스:


중첩된 클래스는 다른 클래스 내에서 class 키워드를 사용하여 선언됩니다.
기본적으로 외부 클래스 인스턴스에 대한 참조를 보유하지 않는 정적 클래스입니다.
외부 클래스의 public 및 internal 멤버만 액세스할 수 있습니다.
중첩 클래스를 인스턴스화하는 구문은 OuterClass.NestedClass()입니다.
외부 클래스의 인스턴스 또는 해당 멤버에 대한 액세스 권한이 없습니다.

내부 클래스:


내부 클래스는 다른 클래스 내부에서 inner 키워드를 사용하여 선언됩니다.
비정적 클래스이므로 외부 클래스의 인스턴스에 대한 참조를 보유합니다.
외부 클래스의 public 및 private 멤버 모두에 액세스할 수 있습니다.
내부 클래스를 인스턴스화하는 구문은 OuterClass().InnerClass()이며 외부 클래스의 인스턴스가 필요합니다.
외부 클래스의 인스턴스와 해당 멤버에 액세스할 수 있습니다.

2. 클래스 프로퍼티

프로퍼티를 읽거나 접근하려면 프로퍼티 선언 바로 뒤에 get 함수를 선언하고 각 프로퍼티와 함께 제공되는 암묵적 백킹 필드를 사용해 실제 데이터를 저장해야 함
field 키워드를 사용하여 백킹 필드에 접근 가능

클래스 프로퍼티를 설정하거나 작성하려면 프로퍼티 뒤나 get 함수 뒤에 set 함수를 선언함 -> set 함수는 value 라는 매개변수 하나를 사용해 백킹 필드를 갱신

백킹 필드란 -> 컴파일러에서 암시적으로 생성하는 필드를 참조 -> 프로퍼티를 참조하면 컴파일러는 자동으로 프로퍼티와 연결된 실제 값을 보유하기 위해 백그라운드에서 백킹 필드를 생성

ex) class Example {
    var property: String = "initial value"
        get() = field
        set(value) {
            field = value
        }
}

3. 위임 프로퍼티

프로퍼티는 직접 접근하거나 백킹 필드와 함께 접근할 수 있다

프로퍼티 자체 클래스에서 지원되지 않지만 대신 다른 클래스에 책임이 주어지면 이러한 프로퍼티를 위임 프로퍼티라고 함께

by 키워드를 사용 -> get, set 이 아닌 다른 클래스에서 짬 맞았기 때문에 getValue, setValue로 구현, val 프로퍼티일 경우 getValue 함수만 구현

operator fun -> 위임 속성 기능 중 일부 -> 이것을 이용하여 다른 클래스에 값을 위임

요약하자면 lazy 의 동작 방법

lazy 함수는 위임된 속성과 getValue() 메서드가 사용되는 일반적인 사용 사례입니다.


lazy 함수를 사용하여 위임된 속성을 만들 때 속성에 처음 액세스할 때 getValue() 메서드가 호출됩니다. 속성에 대한 초기화 논리를 정의할 수 있습니다. getValue() 메서드는 속성의 초기 값을 계산하고 반환하는 역할을 합니다.


lazy 함수는 초기 값의 계산을 정의하는 람다 매개변수를 사용합니다. 람다는 속성에 처음 액세스할 때 한 번만 실행됩니다. 초기 계산 후 값이 캐시되고 속성에 대한 후속 액세스는 다시 계산하지 않고 캐시된 값을 검색합니다.

4. 기본 제공 위임자

Observable 위임자가 이에 해당되며 프로퍼티에 값이 할당될 때 시작

Observable 위임자는 다음의 매개변수를 가짐
- 첫 번째 매개변수는 프로퍼티의 초깃값
- 두 번째 매개변수는 프로퍼티 유형, 이전 값, 새 값, 람다식

프로퍼티 값이 변경될 때 마다 시작이 됨